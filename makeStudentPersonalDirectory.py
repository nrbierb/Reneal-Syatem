#!/usr/bin/env python3
# coding:utf-8
# Author:  Neal Bierbaum --<>
# Purpose: 
# Created: 03/07/2013
"""
This is a partner program to studentSignIn. It is suid root to allow an
unprivileged user to create a student personal directory. It takes a single
argument - the requested directory name that has been generated by
studentSignIn. The name is compared with directory names generated from the
student data csv file. If a match is found then it is a legal directory to
create. It will create the student personal directory and internal contents.
If necessary, it will create the parent directories. If no match is found
nothing will be done and the program will exit with a -1 error condition.
"""
import argparse
import csv
import grp
import os
import string
import subprocess
import sys
import syslog

StudentDataFile = "/client_home/share/student_list.csv"
BaseDirectory = "/client_home_students"
ChildDirectories = ["Documents", "Projects"]
GuestDirectory = os.path.join(BaseDirectory, "GuestUser")
SecurityFlagFile = "/client_home/share/security_on"
PROGRAM_NAME = "makeStudentPersonalDirectory"
PROGRAM_DESCRIPTION = "Setup personal directories for the signed in student."
PROGRAM_VERSION = "1.5"


def cleanup_string(original_string, title_case=False,
                   further_remove_characters=".,", join_character="",
                   remove_leading_numbers=False):
    """
    Change unusable special characters to similar ascii.
    Remove most punctuation characters
    :param original_string:
    :param title_case: Convert to title case if true
    :param further_remove_characters: other characters that should not be in string
    :param join_character: the character used to connect the parts of the string after
            cleanup
    :param remove_leading_numbers: Names may be prefixed with leading numbers
            that should be removed but student group names may have leading numbers
    :return: processed string
    """
    try:
        # remove all garbage characters
        clean_string = ''.join([s for s in original_string if s in string.printable])
        clean_string = clean_string.strip()
        # if this is just a number for a grade, return it immediately
        if clean_string.isdigit():
            return clean_string
        if remove_leading_numbers:
            clean_string = clean_string.lstrip("0123456789.")
        # Always remove unwanted stuff at both ends
        clean_string = clean_string.strip(".-")
        clean_string = clean_string.strip()
        target_characters = '!"#$%&\'()*+/:;<=>?@[\\]^`{|}~' + \
                            further_remove_characters
        replacement_characters = " " * len(target_characters)
        cleanup_translator = str.maketrans(target_characters, replacement_characters)
        clean_string = clean_string.translate(cleanup_translator)
        if title_case:
            clean_string = clean_string.title()
        clean_string = join_character.join(clean_string.split())
        return clean_string.strip()
    except ValueError:
        return "---"


def command_run_successful(shell_command):
    """
    Run a single command and test for correct completion
    """
    result = True
    try:
        subprocess.check_output(shell_command, shell=True,
                                universal_newlines=True,
                                stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError:
        result = False
    return result


def name_ok(reader, year_name, group_name, requested_name, base_dirname):
    """
    Create directory names from a csv file that contains all of the
    information about the students. The file should begin with column names
    and include the columns "Class Year", "Section Name", "Student first
    name", "Student middle name", "Student last name". Column order is
    unimportant and any other columns will be ignored. Compare the requested
    name with each generated name. If equal then this is a legal directory
    name.
    """
    for entry in reader:
        year_dirname = cleanup_string(entry[year_name])
        section_dirname = cleanup_string(entry[group_name])
        student_dirname = "%s-%s%s" \
                          % (cleanup_string(entry["Last Name"]),
                             cleanup_string(entry["First Name"]),
                             cleanup_string(entry["Middle Name"]))
        compare_name = os.path.join(base_dirname, year_dirname, section_dirname,
                                    student_dirname)
        if compare_name == requested_name:
            return True
    return False


def split_directory_name(directory_name):
    try:
        real_name = os.path.realpath(directory_name)
        all_parts = real_name.split(os.sep)
        all_parts.pop(0)
        return all_parts
    except (IndexError, OSError):
        return [""]

def test_valid_directory(directory_name, throw_exception=True, full_name_check=True,
                         must_exist=False):
    """
    Assure that any directory to be used as a student directory is in the /client_home_students
    top level directory and that the directory name has been correctly constructed.
    :param full_name_check:
    :param throw_exception:
    :param directory_name:
    :param must_exist:
    :return:
    """
    name_parts = split_directory_name(directory_name)
    try:
        valid = name_parts[0] == "client_home_students"
        if full_name_check and valid:
            valid = name_parts[1] == "GuestUser" or str(name_parts[3]).find("-") != -1
            if must_exist and valid:
                valid = os.path.exists(directory_name) and os.path.isdir(directory_name)
    except (IndexError, OSError):
        valid = False
    if not valid and throw_exception:
        raise ValueError("Invalid directory path %s" % directory_name)
    return valid

def test_valid_path(path, throw_exception=False, is_dir=False,
                         must_exist=False, not_link=False):
    """
    Assure that any directory to be used as a student directory is in the /client_home_students
    top level directory and that the directory name has been correctly constructed.
    :param full_name_check:
    :param throw_exception:
    :param directory_name:
    :param must_exist:
    :return:
    """
    valid = False
    prefix_dict = ["/client_", "/usr/sh"]
    try:
        if path[0:8] in prefix_dict:
            directory = os.path.isdir(path) or not is_dir
            exists = os.path.exists(path) or not must_exist
            not_symbolic_link = not os.path.islink(path) or not not_link
            valid = directory and exists and not_symbolic_link
    except (IndexError, OSError):
        valid = False
    if not valid and throw_exception:
        raise ValueError("Invalid path %s" % path)
    return valid

def make_personal_area(directory_name):
    """
    Create a student personal area directory with its internal contents. If
    necessary, create the upper level directories as well setting owner and
    permisssions on all. If the personal area directory already exists no
    further action will be taken.
    Note:
    """
    global ChildDirectories
    teacher_gid = grp.getgrnam("teacher").gr_gid
    root_id = 0
    test_valid_directory(directory_name)
    parent_path = os.path.realpath(os.path.dirname(directory_name))
    # create top level directory if necessary
    if not os.path.exists(parent_path):
        os.makedirs(parent_path,0o755)
        os.chown(parent_path, root_id, root_id)
        # make student dir
    os.mkdir(directory_name)
    os.chmod(directory_name, 0o755)
    for name in ChildDirectories:
        child_dirname = os.path.join(directory_name, name)
        os.mkdir(child_dirname)
        os.chown(directory_name, root_id, teacher_gid)
        os.chmod(directory_name, 0o777)

def make_personal_area(directory_name):
    """
    Create a student personal area directory with its internal contents. If
    necessary, create the upper level directories as well setting owner and
    permisssions on all. If the personal area directory already exists no
    further action will be taken.
    Note:
    """
    global ChildDirectories
    teacher_gid = grp.getgrnam("teacher").gr_gid
    root_id = 0
    os.makedirs(directory_name, 0o755)
    command_run_successful(("chown -R root:root %s" %directory_name))
    os.chmod(directory_name,0o755)
    for name in ChildDirectories:
        child_dirname = os.path.join(directory_name, name)
        os.mkdir(child_dirname)
        os.chmod(child_dirname,0o770)
        os.chown(child_dirname, root_id, teacher_gid)
    syslog.syslog("Created student directory %s" %directory_name)

def set_owner_and_permissions(directory_name, use_security, student_uid=0):
    """
    Set owner to the logged in user and group to teacher so that teachers may
    always have permission to read and edit student files.
    If security is used, the permissons are set to block access to all except
    the logged in user and teachers. If not, all users may read, write, and
    delete files.
    :param student_uid:
    :param use_security:
    :param directory_name:
    :return:
    """
    global ChildDirectories
    if not student_uid:
        student_uid = os.getuid()
    teacher_gid = grp.getgrnam("teacher").gr_gid
    root_id = 0
    if use_security:
        # Set permissions to block access to all students except the current
        # student. All teachers still have access.
        file_permissions = 0o660
        directory_permissions = 0o770
    else:
        # set permissions to allow access to all
        file_permissions = 0o664
        directory_permissions = 0o775
    # last emergency check -- there have been strange errors
    test_valid_directory(directory_name, must_exist=True)
    os.chown(directory_name, root_id, root_id)
    os.chmod(directory_name, 0o755)
    run_result = subprocess.run(["find", directory_name, "-xdev", "-mindepth", "1", "-type", "f"],
                                stdout=subprocess.PIPE)
    target_list = run_result.stdout.decode("utf8").splitlines()
    for target in target_list:
        if test_valid_path(target, not_link=True, must_exist=True):
            os.chown(target, student_uid, teacher_gid)
            os.chmod(target, file_permissions)
    run_result = subprocess.run(["find", directory_name, "-xdev", "-mindepth", "1", "-type", "d"],
                                stdout=subprocess.PIPE)
    target_list = run_result.stdout.decode("utf8").splitlines()
    for target in target_list:
        if test_valid_path(target, not_link=True, must_exist=True, is_dir=False):
            os.chown(target, student_uid, teacher_gid)
            os.chmod(target, directory_permissions)



def set_open_permissions(top_directory):
    """
    Set world read and write permissions for all directories
    underneath top_directory
    :param top_directory:
    :return:
    """
    test_valid_directory(top_directory, must_exist=True)
    set_owner_and_permissions(top_directory, False, 3001)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog=PROGRAM_NAME,
                                     description=PROGRAM_DESCRIPTION)
    parser.add_argument("-v", "--version", action="version",
                        version=PROGRAM_VERSION)
    parser.add_argument("--year_name", "-y",
                        dest="year_name", default="Form Level",
                        help="The name for the student year level")
    parser.add_argument("--grouping_name", "-g",
                        dest="grouping_name", default="Stream",
                        help="The name For the student group")
    parser.add_argument("--set_open_permissions", "-w", action="store_true",
                        dest="set_open_permissions",
                        help="Set all contents to world read and write")
    parser.add_argument("personal_directory_name",
                        metavar="personal_directory_name", nargs=1,
                        help="The directory to be created.")
    if os.geteuid():
        # not uid 0, root
        print("must be run as root")
        sys.exit(1)
    options = parser.parse_args()
    try:
        personal_directory_name = options.personal_directory_name[0]
        test_valid_directory(personal_directory_name)
        f = open(StudentDataFile, "r", encoding='latin1')
        dict_reader = csv.DictReader(f)
        if options.set_open_permissions:
            set_open_permissions(personal_directory_name)
        elif name_ok(dict_reader, options.year_name, options.grouping_name,
                     personal_directory_name, BaseDirectory):
            if not os.path.exists(personal_directory_name):
                make_personal_area(personal_directory_name)
            # Security is chosen by creating the SecurityFlagFile
            # The file may be empty
            use_owner_security = os.path.exists(SecurityFlagFile)
            set_owner_and_permissions(personal_directory_name,
                                      use_owner_security)
        else:
            err_str = "makeStudentPersonalDirectories attempted to create a directory not in\n" + \
                      "/client_home_students:   %s" % personal_directory_name
            syslog.syslog(err_str)
            sys.exit(1)
    except (IOError, OSError, ValueError) as e:
        syslog.syslog("makeStudentDirectories failed for directory %s: %s"
                      %(personal_directory_name, e))
        sys.exit(1)
